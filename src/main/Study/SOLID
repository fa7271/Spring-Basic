그럼 자바의 가장 큰 특징은  객체 지향 언어  스프링은 객체 지향 언어가 가진 특징인 유연성과 확장성을 잘 살리는 프레임워크로써 좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와준다.

1. SRP 단일 책임 원칙

클래스를 변경하는 이유는 단 한 개여야 한다.
한 클래스는 하나의 책임만 가져야 한다.
하나의 책임이라는 것은 모호하다.
   >> 클 수도 있고, 작을 수 있다.
   >> 문맥과 상황에 따라 다르다

변경이 있을 때 파급 효과가 적은 단일 책임 원칙을 잘 따르는 것이다.



SRP 단일 책임 원칙을 잘 따른경우

쉬운 테스트 - 책임이 하나인 클래스는 테스트 케이스가 줄어들기 때문에 테스트가 쉬워진다
낮은 결합 - 단일 클래스의 기능이 적어져 종속성이 줄어든다.
쉬운 검색 - 작고 잘 조직된 클래스는 모놀리식 클래스보다 검색하기 쉽다
구현하기 쉬움 - 하나의 책임만 가지고 있기 때문에 구현및 이해가 쉽다.


2. OCP 개방-폐쇄 원칙


소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
즉 기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않는다 라는 뜻이다.

하지만 확장을 하려면, 당연히 기존 코드를 변경해야한다.
이 원칙을 지키기 위해서 주로 객체지향의 추상화와 다형성을 활용한다.
주로 인터페이스를 통해 구현을 한다.

추상화와 다형성이 제대로 지켜지지 않은 코드는 개방 폐쇄 원칙을 어기게 된다.

OCP의 원칙을 제대로 경험한 것이 JDBC이다. 자바에서 JDBC를 사용하면 클라이언트는 데이터베이스가 오라클, Mysql, Maria 어떤 것이든 Connection 설정 부분을 제외하고는 변경할 부분이 없다.


이 원칙을 지키기위한 구현 방법


 1. 확장 될 것과 변경을 엄격히 구분한다.
 2. 이 두 모듈이 만나는 지점에 인터페이스를 정의한다.
 3. 구현에 대한 의존보다는 정의된 인터페이스를 의존하도록 코드를 작성한다.
 4. 변경이 발생하는 부분을 추상화하여 분리한다.


>> 객체지향의 효과 극대화  // 코드 관리 용이



3. LSP 리스코 치환 원칙
리스코 치환 원칙이란 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다 를의미한다.
특정 메소드가 상위 타입을 인자로 사용하면 그타입의 하위 타입도 정상적으로 작동 한다는 것이다.
위 원칙을 위반하게 되면 기능 확장을 위해 많은 부분을 수정해야한다. >> 상속을 잘 정의하여 치환 가능성을 위배되지 않도록 설계한다.



4. DIP 의존관계 역전 원칙


프로그래머는 “추상화에 의존해야지,구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
기전에는 무엇으로도 의존하지 않는 클래스 였는데 추상적인 것인 인터페이스의 의존하게 되었다

>> 이것이 의존의 방향이 역전되었다고한다.


예를들면 자동차와 타이어  타이어는 스노우타이어/일반타이어/광폭타이어가 있다.
자동차가 구체적인 타이어들( 스노우타이어/일반타이어/광폭타이어) 에 의존하는게 아닌 추상화된 타이어에 의존하는 것이다.

상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나, 구체 클래스가 아닌 상위 클래스,
인터페이스, 추상 클래스를 통해 의존하라는 것이 바로 의존 역전 원칙이다.



5 . ISP 인터페이스 분릐의 원칙

한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리.
 >> 가능한 최소한의 인터페이스만을 사용해야한다. 하나의 일반적인 인터페이스 보다는 여러개의 구체적인 인터페이스가 낫다.

srp 는 클래스의 단일책임을 강조하지만 isp는 인터페이스의 단일채임을 강조한다.
isp 는 인터페이스 분리를 통해 목표에 도달한다.


적용 방법

1. 클래스 인터페이스를 통한분리.
클래스의 상속을 이용하여 인터페이스를 나눈다.  이런 구조는 클라이언트에게 변화를 주지 않으면서 인터페이스를 분리하는 효과를 갖음
하지만 인터페이스를 상속받는 순간 인터페이스에 예속되어 제공하느 서비스의 성격이 제한된다.

2. 객체를 통한 분리.
위임 사용   > 이임이란 책임을 다른 클래스나 메소드의 맡기는 것이다.



